use std::{borrow::Cow, str::FromStr};

use anyhow::Context;
use indoc::{concatdoc, formatdoc};

use crate::{EscapedPath, wrapper};

const SCRIPT_TEMPLATE: &str = concatdoc! {"
    #!/usr/bin/env bash
    # Automatically generated by '", env!("CARGO_PKG_NAME"), "'.
"};

#[derive(Debug, PartialEq)]
pub struct EnvVar<'a> {
    pub name: Cow<'a, str>,
    pub value: Cow<'a, str>,
}

impl<'a> EnvVar<'a> {
    #[cfg(test)]
    fn new(name: impl Into<Cow<'a, str>>, value: impl Into<Cow<'a, str>>) -> Self {
        Self {
            name: name.into(),
            value: value.into(),
        }
    }

    pub fn to_bash_export_line(&self) -> anyhow::Result<String> {
        let name = shlex::try_quote(&self.name).context("failed to escape name")?;
        let value = shlex::try_quote(&self.value).context("failed to escape value")?;

        Ok(format!("export {name}={value}\n"))
    }

    pub fn into_owned(self) -> EnvVar<'static> {
        EnvVar {
            name: self.name.clone().into_owned().into(),
            value: self.value.clone().into_owned().into(),
        }
    }
}

impl<'a> TryFrom<&'a str> for EnvVar<'a> {
    type Error = anyhow::Error;

    fn try_from(s: &'a str) -> Result<Self, Self::Error> {
        let (name, value) = s.split_once('=').context("missing '=' separator")?;

        Ok(Self {
            name: name.into(),
            value: value.into(),
        })
    }
}

impl FromStr for EnvVar<'_> {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let env_var = EnvVar::try_from(s)?;
        Ok(env_var.into_owned())
    }
}

#[derive(Default)]
pub struct WrapperParams<'a> {
    pub args: &'a [String],
    pub env_vars: &'a [EnvVar<'a>],
}

impl<'a> WrapperParams<'a> {
    #[cfg(test)]
    fn with_args(args: &'a [String]) -> Self {
        Self {
            args,
            ..Default::default()
        }
    }

    #[cfg(test)]
    fn with_env_vars(env_vars: &'a [EnvVar<'a>]) -> Self {
        Self {
            env_vars,
            ..Default::default()
        }
    }
}

fn generate_binary_wrapper_content(
    unwrapped_bin_path: &EscapedPath,
    params: &WrapperParams,
) -> anyhow::Result<String> {
    // TODO: allow arg passthrough before wrapper args

    // first, add all environment variables to the wrapper
    let mut wrapper = params
        .env_vars
        .iter()
        .map(EnvVar::to_bash_export_line)
        .collect::<anyhow::Result<String>>()
        .context("environment variable generation failed")?;

    // now execute the binary with the wrapper arguments
    wrapper.push_str(&format!(
        r#"exec {unwrapped_path}"#,
        unwrapped_path = unwrapped_bin_path.escaped
    ));

    if !params.args.is_empty() {
        let joined_args = params.args.join(" ");

        wrapper.reserve(1 + joined_args.len());
        wrapper.push(' ');
        wrapper.push_str(&joined_args);
    }

    // passthrough all other arguments
    wrapper.push_str(r#" "\$@""#);

    Ok(wrapper)
}

pub fn generate_binary_wrapper(
    unwrapped_bin_path: &EscapedPath,
    params: &WrapperParams,
) -> anyhow::Result<String> {
    let content = generate_binary_wrapper_content(unwrapped_bin_path, params)?;
    Ok(format!("{SCRIPT_TEMPLATE}{content}"))
}

pub fn generate_wrapper_install(
    paths: &wrapper::GeneratedPaths,
    wrapper_script: &str,
) -> anyhow::Result<String> {
    Ok(formatdoc! { r#"
        {SCRIPT_TEMPLATE}
        mv {wrapped_path} {unwrapped_path}

        cat << _{program_name}_eof > {wrapped_path}
        {wrapper_script}
        _{program_name}_eof

        chmod +x {wrapped_path}
        "#,
        wrapped_path = paths.wrapped_path.escaped,
        unwrapped_path = paths.unwrapped_path.escaped,
        program_name = env!("CARGO_PKG_NAME"),
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    mod env_var {
        use super::*;

        #[test]
        fn to_bash_export_line_succeeds() {
            let env = EnvVar::new("TEST", "value");

            assert_eq!(
                env.to_bash_export_line().expect("expected success"),
                "export TEST=value\n"
            )
        }

        #[test]
        fn bash_export_lines_are_escaped() {
            let env = EnvVar::new(
                // this is not a valid env name, but having it get escaped will make bash catch it instead of creating
                // multiple separate env vars
                "TEST NAME",
                "value with spaces",
            );

            assert_eq!(
                env.to_bash_export_line().expect("expected success"),
                "export 'TEST NAME'='value with spaces'\n"
            )
        }

        #[test]
        fn parse_from_str_succeeds() {
            let env = EnvVar::try_from("ENV=value").expect("env parsing should succeed");
            assert_eq!(env, EnvVar::new("ENV", "value"));
        }

        #[test]
        fn parse_from_str_without_sep_fails() {
            assert!(EnvVar::try_from("ENVvalue").is_err());
        }
    }

    mod generate_binary_wrapper {
        use super::*;

        #[test]
        fn no_args() {
            let path = EscapedPath::new("test_bin").unwrap();
            let result = generate_binary_wrapper_content(&path, &WrapperParams::default()).unwrap();
            assert_eq!(result, r#"exec test_bin "\$@""#);
        }

        #[test]
        fn path_with_space() {
            let path = EscapedPath::new("/usr/bin/test bin").unwrap();
            let result = generate_binary_wrapper_content(&path, &WrapperParams::default()).unwrap();
            assert_eq!(result, r#"exec '/usr/bin/test bin' "\$@""#);
        }

        #[test]
        fn with_args() {
            let path = EscapedPath::new("/usr/bin/test_bin").unwrap();
            let args = &[String::from("--arg1"), String::from("--arg2")];
            let result =
                generate_binary_wrapper_content(&path, &WrapperParams::with_args(args)).unwrap();

            assert_eq!(result, r#"exec /usr/bin/test_bin --arg1 --arg2 "\$@""#);
        }

        #[test]
        fn with_env_vars() {
            let path = EscapedPath::new("/usr/bin/test_bin").unwrap();
            let env_vars = &[EnvVar::new("ENV1", "val1"), EnvVar::new("ENV2", "val2")];

            let result =
                generate_binary_wrapper_content(&path, &WrapperParams::with_env_vars(env_vars))
                    .unwrap();

            assert_eq!(
                result,
                formatdoc! { r#"
                    export ENV1=val1
                    export ENV2=val2
                    exec /usr/bin/test_bin "\$@""#
                }
            );
        }
    }
}
