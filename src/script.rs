use std::path::Path;

use indoc::{concatdoc, formatdoc};

use crate::WrappedBinaryInfo;

const SCRIPT_TEMPLATE: &str = concatdoc! {"
    #!/usr/bin/env bash
    # Automatically generated by '", env!("CARGO_PKG_NAME"), "'.
"};

pub fn generate_binary_wrapper(unwrapped_bin_path: &Path, args: &[String]) -> String {
    // TODO: add env support
    // TODO: allow arg passthrough before wrapper args
    let mut wrapper = format!(
        r#"exec "{unwrapped_path}""#,
        unwrapped_path = unwrapped_bin_path.display()
    );

    if !args.is_empty() {
        let joined_args = args.join(" ");

        wrapper.reserve(1 + joined_args.len());
        wrapper.push(' ');
        wrapper.push_str(&joined_args);
    }

    // passthrough all other arguments
    wrapper.push_str(r#" "\$@""#);

    wrapper
}

pub fn generate_wrapper_install(bin_info: &WrappedBinaryInfo, args: &[String]) -> String {
    let wrapper_content = generate_binary_wrapper(&bin_info.unwrapped_path, args);

    formatdoc! { r#"
        {SCRIPT_TEMPLATE}
        mv "{wrapped_path}" "{unwrapped_path}"

        cat << _{program_name}_eof > "{wrapped_path}"
        {SCRIPT_TEMPLATE}
        {wrapper_content}
        _{program_name}_eof

        chmod +x "{wrapped_path}"
        "#,
        wrapped_path = bin_info.wrapped_path.display(),
        unwrapped_path = bin_info.unwrapped_path.display(),
        program_name = env!("CARGO_PKG_NAME"),
    }
}
