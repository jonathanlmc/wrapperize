use std::{
    fmt::Write as FmtWrite,
    io::Write,
    path::{Path, PathBuf},
    process::{self, Command, Stdio},
};

use anyhow::Context;
use indoc::{concatdoc, formatdoc};
use tap::Tap;

use crate::{env, error::IoError, file, pacman_hook, path};

const SCRIPT_TEMPLATE: &str = concatdoc! {"
    #!/usr/bin/env bash
    # Automatically generated by '", env!("CARGO_PKG_NAME"), "'.
"};

pub struct ExecPaths {
    pub unwrapped: path::Escaped,
    pub wrapped: path::Escaped,
    pub wrapped_filename: String,
}

impl ExecPaths {
    pub fn try_from_path(path: &Path) -> anyhow::Result<Self> {
        let wrapped = path::Escaped::new(path);

        let filename = path
            .file_name()
            .context("invalid path provided")?
            .to_string_lossy()
            .into_owned();

        let unwrapped = path::Escaped::new(path.with_file_name(format!(".{filename}-unwrapped")));

        Ok(Self {
            unwrapped,
            wrapped,
            wrapped_filename: filename,
        })
    }
}

pub struct InstallScript {
    contents: String,
}

impl InstallScript {
    pub fn create(
        paths: &ExecPaths,
        wrapper_script: &str,
        save_to_disk: Option<PathBuf>,
    ) -> anyhow::Result<Self> {
        let wrapper_install_script = Self::generate_script(paths, wrapper_script)
            .context("failed to generate wrapper install script")?;

        if let Some(path) = save_to_disk {
            file::write_with_execute_bit(&path, wrapper_install_script.as_bytes()).with_context(
                || {
                    IoError::new(
                        &path,
                        "failed to write wrapper install script for pacman hook",
                    )
                },
            )?;
        }

        Ok(Self {
            contents: wrapper_install_script,
        })
    }

    pub fn execute(self) -> anyhow::Result<process::ExitStatus> {
        let mut cmd = Command::new("/usr/bin/env")
            .arg("bash")
            .stdin(Stdio::piped())
            .spawn()
            .context("failed to spawn bash to execute wrapper installer")?;

        cmd.stdin
            .take()
            .context("no stdin configured for bash")?
            .write_all(self.contents.as_bytes())
            .context("failed to pipe wrapper install script to bash")?;

        cmd.wait().map_err(Into::into)
    }

    fn generate_script(paths: &ExecPaths, wrapper_script: &str) -> anyhow::Result<String> {
        Ok(formatdoc! { r#"
            {SCRIPT_TEMPLATE}
            mv "{wrapped_path}" "{unwrapped_path}"

            cat << _{program_name}_eof > "{wrapped_path}"
            {wrapper_script}
            _{program_name}_eof

            chmod +x "{wrapped_path}"
            "#,
            wrapped_path = paths.wrapped.escaped,
            unwrapped_path = paths.unwrapped.escaped,
            program_name = env!("CARGO_PKG_NAME"),
        })
    }
}

#[derive(Default)]
pub struct Params<'a> {
    pub args: &'a [String],
    pub env_vars: &'a [env::Variable<'a>],
}

impl<'a> Params<'a> {
    #[cfg(test)]
    fn with_args(args: &'a [String]) -> Self {
        Self {
            args,
            ..Default::default()
        }
    }

    #[cfg(test)]
    fn with_env_vars(env_vars: &'a [env::Variable<'a>]) -> Self {
        Self {
            env_vars,
            ..Default::default()
        }
    }
}

pub fn create(
    paths: &ExecPaths,
    wrapper_params: &Params,
    use_pacman_hooks: bool,
) -> anyhow::Result<InstallScript> {
    let wrapper_already_exists = paths.unwrapped.original.try_exists().with_context(|| {
        IoError::new(
            &paths.unwrapped.original,
            "failed to check if wrapped path already exists",
        )
    })?;

    if wrapper_already_exists {
        return Err(IoError::new(
            &paths.wrapped.original,
            format!(
                "wrapper already exists for this file at `{}`",
                paths.unwrapped.original.display()
            ),
        )
        .into());
    }

    let wrapper_script = generate_full_wrapper_script(&paths.unwrapped, wrapper_params)
        .context("failed to generate binary wrapper")?;

    // the wrapper install script uses the same path / filename as the pacman install hook but with a different
    // extension, so we can initialize the pacman install hook now to simply clone and alter its pre-computed path
    // for the wrapper install script
    let pacman_install_hook = pacman_hook::Hook::new(
        &paths.wrapped_filename,
        pacman_hook::TriggerAction::InstallOrUpdate,
    );

    // the wrapper install script only needs a path if it's going to be saved to disk,
    // and we only need to write it to disk if we're generating pacman hooks
    let wrapper_install_script_path = use_pacman_hooks.then(|| {
        pacman_install_hook.path.clone().tap_mut(|p| {
            p.set_extension("sh");
        })
    });

    let wrapper_install_script =
        InstallScript::create(paths, &wrapper_script, wrapper_install_script_path)?;

    if !use_pacman_hooks {
        return Ok(wrapper_install_script);
    }

    // since we are using pacman hooks, generate their contents and write them all to disk now

    pacman_hook::create_dir()?;

    pacman_install_hook.generate_and_write_to_disk(paths)?;

    pacman_hook::Hook::new(&paths.wrapped_filename, pacman_hook::TriggerAction::Removal)
        .generate_and_write_to_disk(paths)?;

    Ok(wrapper_install_script)
}

fn generate_wrapper_script_content(
    unwrapped_bin_path: &path::Escaped,
    params: &Params,
) -> anyhow::Result<String> {
    // TODO: allow arg passthrough before wrapper args

    let mut wrapper = String::new();

    // first, add all environment variables to the wrapper
    for env in params.env_vars {
        env.write_bash_line(&mut wrapper)?;
    }

    // now execute the binary with the wrapper arguments

    // compile time sanity check: the escaped path should be escaping the same quote
    // character used in the `write!` call
    const _: () = assert!(path::Escaped::ESCAPE_CHAR == '"');
    write!(wrapper, r#"exec "{}""#, unwrapped_bin_path.escaped)?;

    for arg in params.args {
        write!(wrapper, " {}", arg)?;
    }

    // passthrough all other arguments
    write!(wrapper, r#" "\$@""#)?;

    Ok(wrapper)
}

fn generate_full_wrapper_script(
    unwrapped_bin_path: &path::Escaped,
    params: &Params,
) -> anyhow::Result<String> {
    let content = generate_wrapper_script_content(unwrapped_bin_path, params)?;
    Ok(format!("{SCRIPT_TEMPLATE}{content}"))
}

#[cfg(test)]
mod tests {
    use super::*;

    mod generate_wrapper_script {
        use super::*;

        #[test]
        fn no_args() {
            let path = path::Escaped::new("test_bin");
            let result = generate_wrapper_script_content(&path, &Params::default()).unwrap();
            assert_eq!(result, r#"exec "test_bin" "\$@""#);
        }

        #[test]
        fn path_with_space() {
            let path = path::Escaped::new("/usr/bin/test bin");
            let result = generate_wrapper_script_content(&path, &Params::default()).unwrap();
            assert_eq!(result, r#"exec "/usr/bin/test bin" "\$@""#);
        }

        #[test]
        fn path_with_quote() {
            let path = path::Escaped::new("/usr/bin/\"test\"");
            let result = generate_wrapper_script_content(&path, &Params::default()).unwrap();
            assert_eq!(result, r#"exec "/usr/bin/\"test\"" "\$@""#);
        }

        #[test]
        fn with_args() {
            let path = path::Escaped::new("/usr/bin/test_bin");
            let args = &[String::from("--arg1"), String::from("--arg2")];
            let result = generate_wrapper_script_content(&path, &Params::with_args(args)).unwrap();

            assert_eq!(result, r#"exec "/usr/bin/test_bin" --arg1 --arg2 "\$@""#);
        }

        #[test]
        fn with_env_vars() {
            let path = path::Escaped::new("/usr/bin/test_bin");

            let env_vars = &[
                env::Variable::new("ENV1", "val1"),
                env::Variable::new("ENV2", "val2"),
            ];

            let result =
                generate_wrapper_script_content(&path, &Params::with_env_vars(env_vars)).unwrap();

            assert_eq!(
                result,
                formatdoc! { r#"
                    export ENV1="val1"
                    export ENV2="val2"
                    exec "/usr/bin/test_bin" "\$@""#
                }
            );
        }
    }
}
