use std::{
    fmt::{self, Display, Write as FmtWrite},
    io::Write,
    path::Path,
    process::{self, Command, Stdio},
};

use anyhow::Context;
use indoc::{concatdoc, formatdoc};
use tap::Tap;

use crate::{env, error::IoError, file, pacman_hook, path};

const SCRIPT_TEMPLATE: &str = concatdoc! {"
    #!/usr/bin/env bash
    # Automatically generated by '", env!("CARGO_PKG_NAME"), "'.
"};

pub struct ExecPaths {
    pub unwrapped: path::Escaped,
    pub wrapped: path::Escaped,
    pub wrapped_filename: String,
}

impl ExecPaths {
    pub fn try_from_path(path: &Path) -> anyhow::Result<Self> {
        let wrapped = path::Escaped::new(path);

        let filename = path
            .file_name()
            .context("invalid path provided")?
            .to_string_lossy()
            .into_owned();

        let unwrapped = path::Escaped::new(path.with_file_name(format!(".{filename}-unwrapped")));

        Ok(Self {
            unwrapped,
            wrapped,
            wrapped_filename: filename,
        })
    }
}

pub struct InstallScript {
    contents: String,
}

impl InstallScript {
    pub fn create(
        paths: &ExecPaths,
        wrapper_script: impl Display,
        save_to_disk: Option<&Path>,
    ) -> anyhow::Result<Self> {
        let wrapper_install_script = Self::generate_script(paths, wrapper_script)
            .context("failed to generate wrapper install script")?;

        if let Some(path) = save_to_disk {
            file::write_with_execute_bit(path, wrapper_install_script.as_bytes()).with_context(
                || {
                    IoError::new(
                        path,
                        "failed to write wrapper install script for pacman hook",
                    )
                },
            )?;
        }

        Ok(Self {
            contents: wrapper_install_script,
        })
    }

    pub fn execute(self) -> anyhow::Result<process::ExitStatus> {
        let mut cmd = Command::new("/usr/bin/env")
            .arg("bash")
            .stdin(Stdio::piped())
            .spawn()
            .context("failed to spawn bash to execute wrapper installer")?;

        cmd.stdin
            .take()
            .context("no stdin configured for bash")?
            .write_all(self.contents.as_bytes())
            .context("failed to pipe wrapper install script to bash")?;

        cmd.wait().map_err(Into::into)
    }

    fn generate_script(paths: &ExecPaths, wrapper_script: impl Display) -> anyhow::Result<String> {
        Ok(formatdoc! { r#"
            {SCRIPT_TEMPLATE}
            mv "{wrapped_path}" "{unwrapped_path}"

            cat << _{program_name}_eof > "{wrapped_path}"
            {wrapper_script}
            _{program_name}_eof

            chmod +x "{wrapped_path}"
            "#,
            wrapped_path = paths.wrapped.escaped,
            unwrapped_path = paths.unwrapped.escaped,
            program_name = env!("CARGO_PKG_NAME"),
        })
    }
}

#[derive(Default)]
pub struct Params<'a> {
    pub args: &'a [String],
    pub add_passthrough_args_first: bool,
    pub env_vars: &'a [env::Variable<'a>],
}

impl<'a> Params<'a> {
    #[cfg(test)]
    fn with_args(args: &'a [String]) -> Self {
        Self {
            args,
            ..Default::default()
        }
    }

    #[cfg(test)]
    fn with_env_vars(env_vars: &'a [env::Variable<'a>]) -> Self {
        Self {
            env_vars,
            ..Default::default()
        }
    }
}

pub fn create(
    paths: &ExecPaths,
    wrapper_params: &Params,
    use_pacman_hooks: bool,
) -> anyhow::Result<InstallScript> {
    let wrapper_already_exists = paths.unwrapped.original.try_exists().with_context(|| {
        IoError::new(
            &paths.unwrapped.original,
            "failed to check if wrapped path already exists",
        )
    })?;

    if wrapper_already_exists {
        return Err(IoError::new(
            &paths.wrapped.original,
            format!(
                "wrapper already exists for this file at `{}`",
                paths.unwrapped.original.display()
            ),
        )
        .into());
    }

    let wrapper_script_fmt =
        fmt::from_fn(|writer| write_full_wrapper_script(&paths.unwrapped, wrapper_params, writer));

    // the wrapper install script uses the same path / filename as the pacman install hook but with a different
    // extension, so we can initialize the pacman install hook now to simply clone and alter its pre-computed path
    // for the wrapper install script
    let pacman_install_hook = pacman_hook::Hook::new(
        &paths.wrapped_filename,
        pacman_hook::TriggerAction::InstallOrUpdate,
    );

    // the wrapper install script only needs a path if it's going to be saved to disk,
    // and we only need to write it to disk if we're generating pacman hooks
    let wrapper_install_script_path = use_pacman_hooks.then(|| {
        pacman_install_hook.path.clone().tap_mut(|p| {
            p.set_extension("sh");
        })
    });

    let wrapper_install_script = InstallScript::create(
        paths,
        wrapper_script_fmt,
        wrapper_install_script_path.as_deref(),
    )?;

    // the install script path is only present if we're using pacman hooks, so we
    // can use it to determine if we should skip the hook setup, and unwrap the
    // path value at the same time for later use
    let Some(wrapper_install_script_path) = wrapper_install_script_path else {
        return Ok(wrapper_install_script);
    };

    // since we are using pacman hooks, generate their contents and write them all to disk now

    pacman_hook::create_dir()?;

    pacman_install_hook.generate_and_write_to_disk(paths)?;

    pacman_hook::Hook::new(
        &paths.wrapped_filename,
        pacman_hook::TriggerAction::Removal {
            wrapper_install_script_path,
        },
    )
    .generate_and_write_to_disk(paths)?;

    Ok(wrapper_install_script)
}

fn write_wrapper_script_content(
    unwrapped_exec_path: &path::Escaped,
    params: &Params,
    mut writer: impl FmtWrite,
) -> fmt::Result {
    // first, add all environment variables to the wrapper
    for env in params.env_vars {
        env.write_bash_line(&mut writer)?;
    }

    // now run the executable with the wrapper arguments

    // compile time sanity check: the escaped path should be escaping the same quote
    // character used in the `write!` call
    const _: () = assert!(path::Escaped::ESCAPE_CHAR == '"');
    write!(writer, r#"exec "{}""#, unwrapped_exec_path.escaped)?;

    fn write_passthrough(mut writer: impl FmtWrite) -> fmt::Result {
        write!(writer, r#" "\$@""#)
    }

    fn write_args(params: &Params, mut writer: impl FmtWrite) -> fmt::Result {
        for arg in params.args {
            write!(writer, " {}", arg)?;
        }

        Ok(())
    }

    if params.add_passthrough_args_first {
        write_passthrough(&mut writer)?;
        write_args(params, &mut writer)?;
    } else {
        write_args(params, &mut writer)?;
        write_passthrough(&mut writer)?;
    }

    Ok(())
}

fn write_full_wrapper_script(
    unwrapped_exec_path: &path::Escaped,
    params: &Params,
    mut writer: impl FmtWrite,
) -> fmt::Result {
    writer.write_str(SCRIPT_TEMPLATE)?;
    write_wrapper_script_content(unwrapped_exec_path, params, writer)
}

#[cfg(test)]
mod tests {
    use super::*;

    mod generate_wrapper_script {
        use super::*;

        fn gen_script_content(path: &path::Escaped, params: &Params) -> anyhow::Result<String> {
            let mut buffer = String::new();
            write_wrapper_script_content(path, params, &mut buffer)?;
            Ok(buffer)
        }

        #[test]
        fn no_args() {
            let path = path::Escaped::new("test_bin");
            let result = gen_script_content(&path, &Params::default()).unwrap();
            assert_eq!(result, r#"exec "test_bin" "\$@""#);
        }

        #[test]
        fn path_with_space() {
            let path = path::Escaped::new("/usr/bin/test bin");
            let result = gen_script_content(&path, &Params::default()).unwrap();
            assert_eq!(result, r#"exec "/usr/bin/test bin" "\$@""#);
        }

        #[test]
        fn path_with_quote() {
            let path = path::Escaped::new("/usr/bin/\"test\"");
            let result = gen_script_content(&path, &Params::default()).unwrap();
            assert_eq!(result, r#"exec "/usr/bin/\"test\"" "\$@""#);
        }

        #[test]
        fn with_args() {
            let path = path::Escaped::new("/usr/bin/test_bin");
            let args = &[String::from("--arg1"), String::from("--arg2")];
            let result = gen_script_content(&path, &Params::with_args(args)).unwrap();

            assert_eq!(result, r#"exec "/usr/bin/test_bin" --arg1 --arg2 "\$@""#);
        }

        #[test]
        fn with_env_vars() {
            let path = path::Escaped::new("/usr/bin/test_bin");

            let env_vars = &[
                env::Variable::new("ENV1", "val1"),
                env::Variable::new("ENV2", "val2"),
            ];

            let result = gen_script_content(&path, &Params::with_env_vars(env_vars)).unwrap();

            assert_eq!(
                result,
                formatdoc! { r#"
                    export ENV1="val1"
                    export ENV2="val2"
                    exec "/usr/bin/test_bin" "\$@""#
                }
            );
        }

        #[test]
        fn passthrough_args_first() {
            let path = path::Escaped::new("/usr/bin/test_bin");

            let result = gen_script_content(
                &path,
                &Params {
                    args: &[String::from("--arg1"), String::from("--arg2")],
                    add_passthrough_args_first: true,
                    ..Default::default()
                },
            )
            .unwrap();

            assert_eq!(
                result,
                formatdoc! { r#"
                    exec "/usr/bin/test_bin" "\$@" --arg1 --arg2"#
                }
            );
        }
    }
}
